%{
/* Declarations section */
    #include "Classes.h"
    #include "hw3_output.hpp"

    extern int yylex();
    extern int yylineno;

    int yyerror(const char * message);

    namespace GlobalSemanticStateHandler {
        // global variables declarations:
        //todo:start
        int switchId = 0;
        int maxSwitch = 0;
        Registers registerPool;
        CodeBuffer &buffer = CodeBuffer::instance();
        //todo:end
        vector<shared_ptr<SymbolTable>> symbolTablesStack; // stack of SymbolTables for scope-management
        stack<int> offsetStack; // stack used to keep track of the current offsets in nested scopes
        int nestedLoopDepth = 0; // counter variable used to keep track of the nested loops' depth.
        bool isInSwitchState = false; // self explanatory indicator flag
        string currentFunctionId; // value is always "" except if we are within a function scope
        //todo:start
        int currentRunningFunctionArgumentsNumber = 0;
        int switchCounter = 0;

        string GetLLVMType(string type) {
            if (type == "VOID") {
                if (DEBUG) printMessage("void type");
                return "void";
            } else if (type == "BOOL") {
                if (DEBUG) printMessage("i1 type");
                return "i1";
            } else if (type == "BYTE") {
                if (DEBUG) printMessage("i8 type");
                return "i8";
            } else if (type == "STRING") {
                if (DEBUG) printMessage("i8 pointer type");
                return "i8*";
            } else return "i32";
        }

        string zeroExtendType(string originalReg, string llvmType) {
            string destReg = registerPool.GetNewRegister();
            buffer.emit("%" + destReg + " = zext " + llvmType + " %" + originalReg + " to i32");
            return destReg;
        }

        //todo:end

        // global functions declarations:

        // state handlers:
        void openScope();
        void closeScope();
        void enterLoopState();
        void exitLoopState();
        void enterSwitchState();
        void exitSwitchState();
        void exitProgramFuncsState(); // entering this state is already handled and happens once
        void exitProgramRuntimeState(); // same as here ^

        // helper functions:
        shared_ptr<SymbolTableRecord> makeParamSymbolRecord(string value,
                                                            vector<string> currentParamType,
                                                            int currentOffset);
        void insertFunctionParametersToSymbolTable(Formals *formals);
        bool isDeclaredVariable(const string &name);
        bool isDeclared(const string &name);
    }
%}

/* Rules section */

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc BOOL;
%nonassoc ID
%nonassoc NUM
%nonassoc B;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc IF;
%nonassoc CASE;
%nonassoc ELSE;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SWITCH
%nonassoc DEFAULT
%nonassoc COLON
%nonassoc SC;
%nonassoc COMMA;
%nonassoc STRING;
%right ASSIGN
%left OR
%left AND
%left EQ
%nonassoc REL
%left PLUS_MINUS
%left MUL_DIV
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%nonassoc SECOND_PRIOR;
%nonassoc FIRST_PRIOR;
%%

/* Note: dynamic casts are done to force the correct constructors */

Program :       {
                    $$ = new Program();
                } Funcs
                {
                    GlobalSemanticStateHandler::exitProgramRuntimeState();
                }

Funcs :         %prec SECOND_PRIOR
                {
                    $$ = new Funcs();
                }

Funcs :         FuncDecl Funcs %prec FIRST_PRIOR
                {
                    $$ = new Funcs();
                }

FuncDecl:       RetType ID LPAREN Formals RPAREN
                {
                    $$ = new FuncDecl(dynamic_cast<RetType*>($1),$2,dynamic_cast<Formals*>($4));
                } LBRACE OpenScope
                {
                    GlobalSemanticStateHandler::insertFunctionParametersToSymbolTable(dynamic_cast<Formals*>($4));
                } Statements CloseScope
                {
                    exitProgramFuncs(dynamic_cast<RetType*>($1));} RBRACE {$$ = $6;};

RetType:        Type
                {
                    $$ = new RetType(dynamic_cast<Type*>($1));
                }

RetType:        VOID
                {
                    $$ = new RetType($1);
                }

Formals:        {
                    $$ = new Formals();
                }

Formals:        FormalsList
                {
                    $$ = new Formals(dynamic_cast<FormalsList*>($1));
                }

FormalsList:    FormalDecl
                {
                    $$ = new FormalsList(dynamic_cast<FormalDecl*>($1));
                }

FormalsList:    FormalDecl COMMA FormalsList
                {
                    $$ = new FormalsList(dynamic_cast<FormalDecl*>($1), dynamic_cast<FormalsList*>($3));
                }

FormalDecl:     Type ID
                {
                    $$ = new FormalDecl(dynamic_cast<Type*>($1), $2);
                }

Statements:     Statement
                {
                    $$ = new Statements(dynamic_cast<Statement*>($1));
                }

Statements:     Statements Statement
                {
                    $$ = new Statements(dynamic_cast<Statements*>($1), dynamic_cast<Statement*>($2));
                }

Statement:      LBRACE OpenScope Statements CloseScope RBRACE
                {
                    $$ = new Statement(dynamic_cast<Statements*>($3));
                }

Statement:      Type ID SC
                {
                    $$ = new Statement(dynamic_cast<Type*>($1),$2);
                }

Statement:      Type ID ASSIGN Exp SC
                {
                    $$ = new Statement(dynamic_cast<Type*>($1),$2, dynamic_cast<Exp*>($4));
                }

Statement:      ID ASSIGN Exp SC
                {
                    $$ = new Statement($1, dynamic_cast<Exp*>($3));
                }

Statement:      Call SC
                {
                    $$ = new Statement(dynamic_cast<Call*>($1));
                }

Statement:      RETURN SC
                {
                    $$ = new Statement("VOID");
                }

Statement:      RETURN Exp SC
                {
                    $$ = new Statement(dynamic_cast<Exp*>($2));
                }

Statement:      IF LPAREN SExp RPAREN OpenScope M Statement %prec IF
                {
                    $$ = new Statement("if", dynamic_cast<Exp*>($3), dynamic_cast<Statement*>($7));closeCurrentScope();backpatchIf(dynamic_cast<M*>($6), dynamic_cast<Exp*>($3));
                }

Statement:      IF LPAREN SExp RPAREN OpenScope M Statement ELSE
                {
$$ = new Statement("if else", dynamic_cast<Exp*>($3), dynamic_cast<Statement*>($7));closeCurrentScope();} OS N Statement CS {backpatchIfElse(dynamic_cast<M*>($6),dynamic_cast<N*>($11), dynamic_cast<Exp*>($3));$$ = mergeIfElseLists(dynamic_cast<Statement*>($9),dynamic_cast<Statement*>($12));
                }

Statement:      WHILE LPAREN N Exp RPAREN
                {
                    $$ = parseBooleanCondition(dynamic_cast<Exp*>($4));} {$$ = new Statement("while", dynamic_cast<Exp*>($4));enterLoop();
                } OpenScope Statement CloseScope
                {
                    exitLoop(dynamic_cast<N*>($3),dynamic_cast<P*>($6),dynamic_cast<Statement*>($9)), $$ = $7;
                }

Statement:      BREAK SC
                {
                    $$ = new Statement($1);
                }

Statement:      CONTINUE SC
                {
                    $$ = new Statement($1);
                }

Statement:      SWITCH
                {
                    GlobalSemanticStateHandler::enterSwitchState();
                } LPAREN Exp
                {
                    new Exp(dynamic_cast<Exp*>($4), "switch");
                } RPAREN LBRACE OpenScope CaseList
                {
                    $$ = new Statement(dynamic_cast<Exp*>($4), dynamic_cast<CaseList*>($9));
                } CloseScope
                {
                    GlobalSemanticStateHandler::exitSwitchState();
                } RBRACE

Call:           ID LPAREN ExpList RPAREN
                {
                    $$ = new Call($1, dynamic_cast<ExpList*>($3));
                }

Call:           ID LPAREN RPAREN
                {
                    $$ = new Call($1);
                }

ExpList:        Exp
                {
                    $$ = new ExpList(dynamic_cast<Exp*>($1));
                }

ExpList:        Exp COMMA ExpList
                {
                    $$ = new ExpList(dynamic_cast<Exp*>($1), dynamic_cast<ExpList*>($3));
                }

Type:           INT
                {
                    $$ = new Type($1);
                }

Type:           BYTE
                {
                    $$ = new Type($1);
                }

Type:           BOOL
                {
                    $$ = new Type($1);
                }

Exp:            LPAREN Exp RPAREN
                {
                    $$ = new Exp(dynamic_cast<Exp*>($2));
                }

Exp:            Exp PLUS_MINUS Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1),$2,dynamic_cast<Exp*>($3), "PLUS_MINUS");
                }

Exp:            Exp MUL_DIV Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "MUL_DIV");
                }

Exp:            ID
                {
                    $$ = new Exp($1);
                }

Exp:            Call
                {
                    $$ = new Exp(dynamic_cast<Call*>($1));
                }

Exp:            NUM
                {
                    $$ = new Exp($1, "NUM");
                }

Exp:            NUM B
                {
                    $$ = new Exp($1, "BYTE");
                }

Exp:            STRING
                {
                    $$ = new Exp($1, "STRING");
                }

Exp:            TRUE
                {
                    $$ = new Exp($1, "BOOL");
                }

Exp:            FALSE
                {
                    $$ = new Exp($1, "BOOL");
                }

Exp:            NOT Exp
                {
                    $$ = new Exp($1, dynamic_cast<Exp*>($2));
                }

Exp:            Exp AND Exp
                {
                    $$ = parseBooleanCondition(dynamic_cast<Exp*>($1));} Exp{$$ = new Exp(dynamic_cast<Exp*>($1),$2,dynamic_cast<Exp*>($4), "AND", dynamic_cast<P*>($3));
                }

Exp:            Exp OR Exp
                {
                    $$ = parseBooleanCondition(dynamic_cast<Exp*>($1));} Exp{$$ = new Exp(dynamic_cast<Exp*>($1),$2,dynamic_cast<Exp*>($4), "OR", dynamic_cast<P*>($3));
                }

Exp:            Exp EQ Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "EQ");
                }

Exp:            Exp REL Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "REL");
                }

CaseList:       CaseDecl CaseList
                {
                    $$ = new CaseList(dynamic_cast<CaseDecl*>($1), dynamic_cast<CaseList*>($2));
                }

CaseList:       CaseDecl
                {
                    $$ = new CaseList(dynamic_cast<CaseDecl*>($1));
                }

CaseList:       DEFAULT COLON N Statements
                {
                    $$ = new CaseList(dynamic_cast<Statements*>($4), dynamic_cast<N*>($3));
                }

CaseDecl:       CASE OpenCase NUM COLON Statements
                {
                    $$ = new CaseDecl(new Exp($3, "CASE_NUM"), dynamic_cast<Statements*>($5), dynamic_cast<TypeNode*>($2));
                }

OpenScope:      {
                    GlobalSemanticStateHandler::openScope();
                }

/* CloseScope is basically CS */
CloseScope:     {
                    GlobalSemanticStateHandler::closeScope();
                }

SExp :          {
                    Exp {$$ = new Exp(dynamic_cast<Exp*>($1), "STRING");};
                }

M :             {
                    $$ = new M();
                };
N :             {
                    $$ = new N();
                };
OpenCase :      {
                    $$ = new TypeNode("OpenCase");
                }

%%

/* Code section */
Variable::Variable() : value() { }

Variable::Variable(string str) {
    if (str == "void") {
        value = "VOID";
    } else if (str == "bool") {
        value = "BOOL";
    } else if (str == "byte") {
        value = "BYTE";
    } else if (str == "int") {
        value = "INT";
    } else {
        value = str;
    }
}

ostream &operator<<(ostream &os, const Variable &node) {
    os << "value: " << node.value;

    return os;
}

shared_ptr<SymbolTableRecord> Program::initPrintFunc() {
    return std::make_shared<SymbolTableRecord>(SymbolTableRecord("print", {"STRING", "VOID"}, 0, true));
}

shared_ptr<SymbolTableRecord> Program::initPrintIFunc() {
    return std::make_shared<SymbolTableRecord>(SymbolTableRecord("printi", {"INT", "VOID"}, 0, true));
}

Program::Program() : Variable("Program") {
    shared_ptr<SymbolTable> symbolTable = std::make_shared<SymbolTable>();

    // initializing the print/printi function records in the (global) symbol table
    shared_ptr<SymbolTableRecord> printFunc = initPrintFunc();
    shared_ptr<SymbolTableRecord> printIFunc = initPrintIFunc();

    // putting the print and printi functions declarations in the symbolTable
    symbolTable->records.push_back(printFunc);
    symbolTable->records.push_back(printIFunc);

    // initializing the symbol-table scope stack with global scope symbol-table
    GlobalSemanticStateHandler::symbolTablesStack.push_back(symbolTable);

    // initializing the offset scope stack with the global scope offset
    GlobalSemanticStateHandler::offsetStack.push(0);
}

Funcs::Funcs() {
    if (strcmp(yytext, "") != 0) {
        // if the last lexeme is empty then it's a syntax error
        output::errorSyn(yylineno);

        exit(0);
    }
}

shared_ptr<SymbolTableRecord> FuncDecl::buildSymbolTableRecordFromFuncDecl() {
    return std::make_shared<SymbolTableRecord>(value, functionParamsTypes, 0, true);
}

FuncDecl::FuncDecl(RetType *retType, Variable *id, Formals *funcParams) {
    if (GlobalSemanticStateHandler::isDeclared(id->value)) {
        // duplicate declaration
        output::errorDef(yylineno, id->value);

        exit(0);
    }

    for (auto iter = funcParams->formals.begin(); iter != funcParams->formals.end(); ++iter) {
        if (GlobalSemanticStateHandler::isDeclared((*iter)->value) ||
            (*iter)->value == id->value) {
            // if the function name or the parameters names shadow declarations from outer scopes
            output::errorDef(yylineno, id->value);

            exit(0);
        }

        // iterating the parameters' names to check if there are duplicate parameters names
        for (auto iter2 = iter + 1; iter2 != funcParams->formals.end(); ++iter2) {
            if ((*iter)->value == (*iter2)->value) {
                output::errorDef(yylineno, (*iter)->value);

                exit(0);
            }
        }
    }

    // setting the function name of the function described by the FuncDecl object
    value = id->value;

    if (funcParams->formals.size() != 0) {
        // building the the functionParamsTypes vector of the FuncDecl object
        for (auto &formal : funcParams->formals) {
            functionParamsTypes.push_back(formal->paramType);
        }
    }

    // the last type is the return type
    functionParamsTypes.push_back(retType->value);

    // now adding said function to the symbolTable
    shared_ptr<SymbolTableRecord> funcSymbolRecord = buildSymbolTableRecordFromFuncDecl();

    GlobalSemanticStateHandler::symbolTablesStack.back()->records.push_back(funcSymbolRecord);

    // updating current function scope
    GlobalSemanticStateHandler::currentFunctionId = value;
}

Formals::Formals(FormalsList *formalList) {
    formals = vector<FormalDecl *>(formalList->formals);
}

FormalsList::FormalsList(FormalDecl *formalDecl) {
    formals.insert(formals.begin(), formalDecl);
}

FormalsList::FormalsList(FormalDecl *formalDecl, FormalsList *formalsList) {
    formals = vector<FormalDecl *>(formalsList->formals);
    formals.insert(formals.begin(), formalDecl);
}

Statement::Statement(Type *type, Variable *id) {
    if (GlobalSemanticStateHandler::isDeclared(id->value)) {
        output::errorDef(yylineno, id->value);

        exit(0);
    }

    int offset = GlobalSemanticStateHandler::offsetStack.top()++;
    vector<string> variableType = {type->value};
    shared_ptr<SymbolTableRecord> variableRecord = std::make_shared<SymbolTableRecord>(id->value, variableType, offset, false);

    GlobalSemanticStateHandler::symbolTablesStack.back()->records.push_back(variableRecord);
}

Statement::Statement(Type *type, Variable *id, Exp *exp) {
    if (GlobalSemanticStateHandler::isDeclared(id->value)) {
        output::errorDef(yylineno, id->value);

        exit(0);
    }
    if ((type->value == exp->type) || (type->value == "INT" && exp->type == "BYTE")) {
        int offset = GlobalSemanticStateHandler::offsetStack.top()++;
        vector<string> variableType = {type->value};
        shared_ptr<SymbolTableRecord> variableRecord = std::make_shared<SymbolTableRecord>(id->value, variableType, offset, false);

        GlobalSemanticStateHandler::symbolTablesStack.back()->records.push_back(variableRecord);
    } else {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

Statement::Statement(Variable *id, Exp *exp) {
    if (!GlobalSemanticStateHandler::isDeclared(id->value)) {
        output::errorUndef(yylineno, id->value);

        exit(0);
    }
}

Statement::Statement(const string &funcReturnType) {
    // checking if the current function scope is of void type
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->isFunc && record->name == GlobalSemanticStateHandler::currentFunctionId) {
                if (record->type.back() == funcReturnType) {
                } else {
                    output::errorMismatch(yylineno);

                    exit(0);
                }
            }
        }
    }
}

Statement::Statement(Exp *exp) {
    // checking if the current function scope is of the specified type
    if (exp->type == "VOID") {
        output::errorMismatch(yylineno);

        exit(0);
    }

    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->isFunc && record->name == GlobalSemanticStateHandler::currentFunctionId) {
                if (record->type.back() == exp->type) {
                } else if (record->type.back() == "INT" && exp->type == "BYTE") {
                    // do nothing because automatic cast from byte to int is allowed
                } else {
                    output::errorMismatch(yylineno);

                    exit(0);
                }
            }
        }
    }
}

Statement::Statement(string type, Exp *exp) {
    if (exp->type != "BOOL") {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

Statement::Statement(Variable *variable) {
    if (GlobalSemanticStateHandler::nestedLoopDepth == 0 && !GlobalSemanticStateHandler::isInSwitchState) {
        // not withing a loop so break/continue is invalid in this context
        if (variable->value == "break") {
            output::errorUnexpectedBreak(yylineno);

            exit(0);
        } else if (variable->value == "continue") {
            output::errorUnexpectedContinue(yylineno);

            exit(0);
        } else {
        }
    } else if (variable->value == "continue" && GlobalSemanticStateHandler::isInSwitchState) {
        output::errorUnexpectedContinue(yylineno);

        exit(0);
    }
}

Statement::Statement(Exp *exp, CaseList *caseList) {
    // making sure the switch-cases types match
    GlobalSemanticStateHandler::enterSwitchState();

    if (exp->type != "INT" && exp->type != "BYTE") {
        output::errorMismatch(yylineno);

        exit(0);
    }

    for (auto &caseDeclaration : caseList->caseDeclarations) {
        if (caseDeclaration->value != "INT" && caseDeclaration->value != "BYTE") {
            output::errorMismatch(yylineno);

            exit(0);
        }
    }
}

Call::Call(Variable *id) {
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == id->value) {
                if (!record->isFunc) {
                    output::errorUndefFunc(yylineno, id->value);

                    exit(0);
                } else if (record->isFunc && record->type.size() == 1) {
                    value = record->type.back();

                    return;
                } else {
                    record->type.pop_back();
                    output::errorPrototypeMismatch(yylineno, id->value, record->type);

                    exit(0);
                }
            }
        }
    }

    output::errorUndefFunc(yylineno, id->value);

    exit(0);
}

Call::Call(Variable *id, ExpList *list) {
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == id->value) {
                if (!record->isFunc) {
                    output::errorUndefFunc(yylineno, id->value);

                    exit(0);
                } else if (record->isFunc && record->type.size() == list->expressionsList.size() + 1) {
                    for (unsigned int i = 0; i < list->expressionsList.size(); ++i) {
                        if (list->expressionsList[i].type == record->type[i]) {
                            continue;
                        } else if (list->expressionsList[i].type == "BYTE" && record->type[i] == "INT") {
                            continue;
                        }

                        record->type.pop_back();
                        output::errorPrototypeMismatch(yylineno, id->value, record->type);

                        exit(0);
                    }

                    value = record->type.back();

                    return;
                } else {
                    record->type.pop_back();
                    output::errorPrototypeMismatch(yylineno, id->value, record->type);

                    exit(0);
                }
            }
        }
    }

    output::errorUndefFunc(yylineno, id->value);

    exit(0);
}

ExpList::ExpList(Exp *exp) {
    expressionsList.insert(expressionsList.begin(), exp);
}

ExpList::ExpList(Exp *exp, ExpList *expList) {
    expressionsList = vector<Exp>(expList->expressionsList);
    expressionsList.insert(expressionsList.begin(), exp);
}

Exp::Exp(Exp *exp) {
    value = exp->value;
    type = exp->type;
    realBooleanValue = exp->realBooleanValue;
}

Exp::Exp(Exp *exp1, Variable *op, Exp *exp2, const string &taggedType) {
    bool isE1Num = exp1->type == "INT" || exp1->type == "BYTE";
    bool isE2Num = exp2->type == "INT" || exp2->type == "BYTE";
    bool isRelOp = taggedType == "EQ" || taggedType == "REL";
    bool isBinOp = taggedType == "PLUS_MINUS" || taggedType == "MUL_DIV";
    bool isBoolOp = taggedType == "OR" || taggedType == "AND";

    if (isE1Num && isE2Num) {
        if (isRelOp) {
            type = "BOOL";
        } else if (isBinOp) {
            if (exp1->type == "INT" || exp2->type == "INT") {
                type = "INT"; // automatic cast to the wider number type
            } else {
                type = "BYTE";
            }
        }
    } else if (exp1->type == "BOOL" && exp2->type == "BOOL") {
        type = "BOOL";

        if (isBoolOp) {
            if if (op->value == "OR") {
                realBooleanValue = exp1->realBooleanValue || exp2->realBooleanValue;
            } else if (op->value == "AND") {
                realBooleanValue = exp1->realBooleanValue && exp2->realBooleanValue;
            }
        } else {
            // only a boolean operation is allowed between 2 boolean expressions
            output::errorMismatch(yylineno);

            exit(0);
        }
    } else {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

Exp::Exp(Variable *variable) {
    // making sure the variable is declared
    if (!GlobalSemanticStateHandler::isDeclaredVariable(variable->value)) {
        output::errorUndef(yylineno, variable->value);

        exit(0);
    }

    for (auto symbolTableIter = GlobalSemanticStateHandler::symbolTablesStack.rbegin();
         symbolTableIter != GlobalSemanticStateHandler::symbolTablesStack.rend();
         ++symbolTableIter) {
            for (auto &record : (*symbolTableIter)->records) {
                if (record->name == variable->value) {
                    value = variable->value;
                    type = record->type.back();

                    return;
                }
            }
    }
}

Exp::Exp(Variable *variable, string taggedType) : Variable::Variable(variable->value) {
    type = taggedType;

    if (type == "NUM") {
        type = "INT";
    } else if (type == "BYTE") {
        // check that size is legal for type BYTE
        if (stoi(variable->value) > 255) {
            output::errorByteTooLarge(yylineno, variable->value);

            exit(0);
        }
    } else if (type == "BOOL") {
        if (variable->value == "true") {
            realBooleanValue = true;
        } else {
            realBooleanValue = false;
        }
    }
}

Exp::Exp(Variable *variable, Exp *exp) {
    if (exp->type != "BOOL") {
        // not a boolean expression, can't apply NOT
        output::errorMismatch(yylineno);

        exit(0);
    }

    type = "BOOL";
    realBooleanValue = !realBooleanValue; // applying not
}

Exp::Exp(Exp *exp, string tag) {
    if (tag == "switch" && exp->type != "INT" && exp->type != "BYTE") {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

CaseList::CaseList(CaseDecl *caseDecl, CaseList *caseList) : CaseList::CaseList() {
    caseDeclarations = vector<CaseDecl *>(caseList->caseDeclarations);
    caseDeclarations.push_back(caseDecl);
}

CaseList::CaseList(CaseDecl *caseDecl) : CaseList::CaseList() {
    caseDeclarations.push_back(caseDecl);
}

CaseDecl::CaseDecl(Exp *expression, Statements *statements) {
    if (expression->type != "INT" && expression->type != "BYTE") {
        output::errorMismatch(yylineno);

        exit(0);
    }

    value = expression->type;
}

// GlobalSemanticStateHandler namespace

void GlobalSemanticStateHandler::openScope() {
    symbolTablesStack.push_back(make_shared<SymbolTable>());
    offsetStack.push(offsetStack.top());
}

void GlobalSemanticStateHandler::closeScope() {
    shared_ptr<SymbolTable> currentSymbolTable = symbolTablesStack.back();

    output::endScope();

    for (auto &record : currentSymbolTable->records) {
        if (!record->isFunc) {
            output::printID(record->name, record->offset, record->type[0]);
        } else {
            string funcReturnType = record->type.back();

            // that's the return type from the vector
            record->type.pop_back();
            output::printID(record->name, record->offset,
                            output::makeFunctionType(funcReturnType, record->type));
        }
    }

    currentSymbolTable->records.clear();
    symbolTablesStack.pop_back();
    offsetStack.pop();
}

void GlobalSemanticStateHandler::enterLoopState() {
    nestedLoopDepth++;
}

void GlobalSemanticStateHandler::exitLoopState() {
    nestedLoopDepth--;
}

void GlobalSemanticStateHandler::enterSwitchState() {
    isInSwitchState = true;

    //todo:start
        switchCounter++;
        maxSwitch++;
        switchId = maxSwitch;
    //todo:end
}

void GlobalSemanticStateHandler::exitSwitchState() {
    isInSwitchState = false;
}

void GlobalSemanticStateHandler::exitProgramFuncsState() {
    currentFunctionId = "";
}

void GlobalSemanticStateHandler::exitProgramRuntimeState() {
    shared_ptr<SymbolTable> globalScopeSymbolTable = symbolTablesStack.front();
    bool doesMainFuncExist = false;

    // looking if there's a main function in the symbol table of the global scope
    for (auto &record : globalScopeSymbolTable->records) {
        if (record->isFunc && record->name == "main" && record->type.back() == "VOID" &&
            record->type.size() == 1) {
            doesMainFuncExist = true;
        }
    }

    if (!doesMainFuncExist) {
        output::errorMainMissing();

        exit(0);
    }

    closeScope();
}

shared_ptr<SymbolTableRecord> GlobalSemanticStateHandler::makeParamSymbolRecord(string value,
                                                                                vector<string> currentParamType,
                                                                                int currentOffset) {
    return make_shared<SymbolTableRecord>(value, currentParamType, currentOffset, false);
}

void GlobalSemanticStateHandler::insertFunctionParametersToSymbolTable(Formals *formals) {
    int currentOffset;
    vector<string> currentParamType;
    shared_ptr<SymbolTableRecord> currentParamRecord;

    // iterating over all the function parameters and adding each one as a record in the symbol table
    for (unsigned int i = 0; i < formals->formals.size(); ++i) {
        currentOffset =  -i - 1;
        currentParamType = {formals->formals[i]->paramType};

        currentParamRecord = makeParamSymbolRecord(formals->formals[i]->value, currentParamType, currentOffset);

        symbolTablesStack.back()->records.push_back(currentParamRecord);
    }
}

bool GlobalSemanticStateHandler::isDeclaredVariable(const string &name) {
    // traversing the symbol tables of all the scopes to check if the given variable name exists
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == name && !record->isFunc) {
                return true;
            }
        }
    }

    return false;
}

bool GlobalSemanticStateHandler::isDeclared(const string &name) {
    // traversing the symbol tables of all the scopes to check if the given var/func name exists
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == name) {
                return true;
            }
        }
    }

    return false;
}


int main() {
    return yyparse();
}

int yyerror(const char * message) {
    output::errorSyn(yylineno);

    exit(0);
}