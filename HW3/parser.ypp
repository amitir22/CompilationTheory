%{
/* Declarations section */
    #include "SemanticsHandler.h"
    #include "hw3_output.hpp"

    extern int yylex();
    extern int yylineno;
    int yyerror(const char * message);
%}

/* Rules section */

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc IF;
%nonassoc ELSE;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc ID;
%nonassoc NUM;
%nonassoc STRING;
%right ASSIGN;
%left OR;
%left AND;
%left EQ_NEQ_RELOP;
%nonassoc REL_RELOP;
%left ADD_SUB_BINOP;
%left MUL_DIV_BINOP;
%right NOT;
%nonassoc SWITCH;
%nonassoc CASE;
%nonassoc DEFAULT;
%nonassoc COLON;
%left RBRACE;
%left LBRACE;
%left RPAREN;
%left LPAREN;

%nonassoc SECOND_PRIOR;
%nonassoc FIRST_PRIOR;
%%

/* Note: dynamic casts are done to force the correct constructors */

Program :       {
                    $$ = new Program();
                } Funcs
                {
                    GlobalSemanticStateHandler::exitProgramRuntimeState();
                }

Funcs :         %prec SECOND_PRIOR
                {
                    $$ = new Funcs();
                }

Funcs :         FuncDecl Funcs %prec FIRST_PRIOR
                {
                    $$ = new Funcs();
                }

FuncDecl:       RetType ID LPAREN Formals RPAREN
                {
                    $$ = new FuncDecl(dynamic_cast<RetType*>($1),$2,dynamic_cast<Formals*>($4));
                } LBRACE OpenScope
                {
                    GlobalSemanticStateHandler::insertFunctionParameters(dynamic_cast<Formals*>($4));
                } Statements CloseScope
                {
                    GlobalSemanticStateHandler::exitProgramFuncsState();
                } RBRACE

RetType:        Type
                {
                    $$ = new RetType(dynamic_cast<Type*>($1));
                }

RetType:        VOID
                {
                    $$ = new RetType($1);
                }

Formals:        {
                    $$ = new Formals();
                }

Formals:        FormalsList
                {
                    $$ = new Formals(dynamic_cast<FormalsList*>($1));
                }

FormalsList:    FormalDecl
                {
                    $$ = new FormalsList(dynamic_cast<FormalDecl*>($1));
                }

FormalsList:    FormalDecl COMMA FormalsList
                {
                    $$ = new FormalsList(dynamic_cast<FormalDecl*>($1), dynamic_cast<FormalsList*>($3));
                }

FormalDecl:     Type ID
                {
                    $$ = new FormalDecl(dynamic_cast<Type*>($1), $2);
                }

Statements:     Statement
                {
                    $$ = new Statements(dynamic_cast<Statement*>($1));
                }

Statements:     Statements Statement
                {
                    $$ = new Statements(dynamic_cast<Statements*>($1), dynamic_cast<Statement*>($2));
                }

Statement:      LBRACE OpenScope Statements CloseScope RBRACE
                {
                    $$ = new Statement(dynamic_cast<Statements*>($3));
                }

Statement:      Type ID SC
                {
                    $$ = new Statement(dynamic_cast<Type*>($1),$2);
                }

Statement:      Type ID ASSIGN Exp SC
                {
                    $$ = new Statement(dynamic_cast<Type*>($1),$2, dynamic_cast<Exp*>($4));
                }

Statement:      ID ASSIGN Exp SC
                {
                    $$ = new Statement($1, dynamic_cast<Exp*>($3));
                }

Statement:      Call SC
                {
                    $$ = new Statement(dynamic_cast<Call*>($1));
                }

Statement:      RETURN SC
                {
                    $$ = new Statement("VOID");
                }

Statement:      RETURN Exp SC
                {
                    $$ = new Statement(dynamic_cast<Exp*>($2));
                }

Statement:      IF LPAREN Exp RPAREN OpenScope Statement %prec IF
                {
                    $$ = new Statement("if", dynamic_cast<Exp*>($3));
                    GlobalSemanticStateHandler::closeScope();
                }

Statement:      IF LPAREN Exp RPAREN OpenScope Statement ELSE
                {
                    $$ = new Statement("if else", dynamic_cast<Exp*>($3));
                    GlobalSemanticStateHandler::closeScope();
                } OpenScope Statement CloseScope

Statement:      WHILE LPAREN Exp RPAREN
                {
                    $$ = new Statement("while", dynamic_cast<Exp*>($3));
                    GlobalSemanticStateHandler::enterLoopState();
                } OpenScope Statement CloseScope
                {
                    GlobalSemanticStateHandler::exitLoopState();
                }

Statement:      BREAK SC
                {
                    $$ = new Statement($1);
                }

Statement:      CONTINUE SC
                {
                    $$ = new Statement($1);
                }

Statement:      SWITCH
                {
                    GlobalSemanticStateHandler::enterSwitchState();
                } LPAREN Exp
                {
                    new Exp(dynamic_cast<Exp*>($4), "switch");
                } RPAREN LBRACE OpenScope CaseList
                {
                    $$ = new Statement(dynamic_cast<Exp*>($4), dynamic_cast<CaseList*>($9));
                } CloseScope
                {
                    GlobalSemanticStateHandler::exitSwitchState();
                } RBRACE

Call:           ID LPAREN ExpList RPAREN
                {
                    $$ = new Call($1, dynamic_cast<ExpList*>($3));
                }

Call:           ID LPAREN RPAREN
                {
                    $$ = new Call($1);
                }

ExpList:        Exp
                {
                    $$ = new ExpList(dynamic_cast<Exp*>($1));
                }

ExpList:        Exp COMMA ExpList
                {
                    $$ = new ExpList(dynamic_cast<Exp*>($1), dynamic_cast<ExpList*>($3));
                }

Type:           INT
                {
                    $$ = new Type($1);
                }

Type:           BYTE
                {
                    $$ = new Type($1);
                }

Type:           BOOL
                {
                    $$ = new Type($1);
                }

Exp:            LPAREN Exp RPAREN
                {
                    $$ = new Exp(dynamic_cast<Exp*>($2));
                }

Exp:            Exp ADD_SUB_BINOP Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1),$2,dynamic_cast<Exp*>($3), "ADD_SUB_BINOP");
                }

Exp:            Exp MUL_DIV_BINOP Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "MUL_DIV_BINOP");
                }

Exp:            ID
                {
                    $$ = new Exp($1);
                }

Exp:            Call
                {
                    $$ = new Exp(dynamic_cast<Call*>($1));
                }

Exp:            NUM
                {
                    $$ = new Exp($1, "NUM");
                }

Exp:            NUM B
                {
                    $$ = new Exp($1, "BYTE");
                }

Exp:            STRING
                {
                    $$ = new Exp($1, "STRING");
                }

Exp:            TRUE
                {
                    $$ = new Exp($1, "BOOL");
                }

Exp:            FALSE
                {
                    $$ = new Exp($1, "BOOL");
                }

Exp:            NOT Exp
                {
                    $$ = new Exp($1, dynamic_cast<Exp*>($2));
                }

Exp:            Exp AND Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "AND");
                }

Exp:            Exp OR Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "OR");
                }

Exp:            Exp EQ_NEQ_RELOP Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "EQ_NEQ_RELOP");
                }

Exp:            Exp REL_RELOP Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "REL_RELOP");
                }

CaseList:       CaseDecl CaseList
                {
                    $$ = new CaseList(dynamic_cast<CaseDecl*>($1), dynamic_cast<CaseList*>($2));
                }

CaseList:       CaseDecl
                {
                    $$ = new CaseList(dynamic_cast<CaseDecl*>($1));
                }

CaseList:       DEFAULT COLON Statements
                {
                    $$ = new CaseList(dynamic_cast<Statements*>($3));
                }

CaseDecl:       CASE NUM COLON Statements
                {
                    $$ = new CaseDecl(new Exp($2, "NUM"), dynamic_cast<Statements*>($4));
                }

OpenScope:      {
                    GlobalSemanticStateHandler::openScope();
                }

/* CloseScope is basically CS */
CloseScope:     {
                    GlobalSemanticStateHandler::closeScope();
                }

%%

/* Code section */

int main() {
    return yyparse();
}

int yyerror(const char * message) {
    output::errorSyn(yylineno);
    exit(0);
}