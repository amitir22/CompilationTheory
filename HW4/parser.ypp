%{
/* Declarations section */
    #include <iostream> /*todo: try remove*/
    #include <stdlib.h> /*todo: try remove*/
    #include "Classes.h"
    #include "hw3_output.hpp"

    using namespace std; /*todo: try remove*/

    extern int yylex();
    extern int yylineno;

    int yyerror(const char * message);

    namespace GlobalSemanticStateHandler {
        // global variables declarations:
        vector<shared_ptr<SymbolTable>> symbolTablesStack; // stack of SymbolTables for scope-management
        stack<int> offsetStack; // stack used to keep track of the current offsets in nested scopes
        int nestedLoopDepth = 0; // counter variable used to keep track of the nested loops' depth.
        bool isInSwitchState = false; // self explanatory indicator flag
        string currentFunctionId; // value is always "" except if we are within a function scope
        int switchID = 0; // todo: rename?
        int maxSwitch = 0;  // todo: rename?
        RegisterFactory registerFactory = RegisterFactory(); // original name: registerPool todo: delete comment
        CodeBuffer& buffer = CodeBuffer::instance();
        // todo: add variable: varType?

        // global functions declarations:

        // state handlers:
        void openScope();
        void closeScope();
        void enterLoopState();
        void exitLoopState();
        void enterSwitchState();
        void exitSwitchState();
        void exitProgramFuncsState(); // entering this state is already handled and happens once
        void exitProgramRuntimeState(); // same as here ^

        // helper functions:
        shared_ptr<SymbolTableRecord> makeParamSymbolRecord(string value,
                                                            vector<string> currentParamType,
                                                            int currentOffset);
        Statement *mergeIfElseLists(Statement *ifStatement, Statement *elseStatement);
        void insertFunctionParametersToSymbolTable(Formals *formals);
        void backpatchIf(M *label, Exp *exp);
        void backpatchIfElse(M *label1, M *label2, Exp *exp);
        bool isDeclaredVariable(const string &name);
        bool isDeclared(const string &name);
    }
%}

/* Rules section */

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc BOOL;
%nonassoc ID;
%nonassoc NUM;
%nonassoc B;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc IF;
%nonassoc CASE;
%nonassoc ELSE;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SWITCH;
%nonassoc DEFAULT;
%nonassoc COLON;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc STRING;
%right ASSIGN;
%left OR;
%left AND;
%left EQ;
%nonassoc REL;
%left PLUS_MINUS;
%left MUL_DIV;
%right NOT;
%left LPAREN;
%left RPAREN;
%left LBRACE;
%left RBRACE;

%nonassoc SECOND_PRIOR;
%nonassoc FIRST_PRIOR;
%%

Program:        {
                    $$ = new Program();
                } Funcs
                {
                    GlobalSemanticStateHandler::exitProgramRuntimeState();
                }

Funcs:          %prec SECOND_PRIOR
                {
                    $$ = new Funcs();
                }

Funcs:          FuncDecl Funcs %prec FIRST_PRIOR
                {
                    $$ = new Funcs();
                }

FuncDecl:       RetType ID LPAREN Formals RPAREN
                {
                    $$ = new FuncDecl(dynamic_cast<RetType*>($1),$2,dynamic_cast<Formals*>($4));
                } LBRACE OpenScope
                {
                    GlobalSemanticStateHandler::insertFunctionParametersToSymbolTable(dynamic_cast<Formals*>($4));
                } Statements CloseScope
                {
                    // todo: remember to change implementation in exitProgramFuncsState by exitProgramFuncs
                    GlobalSemanticStateHandler::exitProgramFuncsState(dynamic_cast<RetType*>($1));
                } RBRACE
                {
                    $$ = $6;
                }

RetType:        Type
                {
                    $$ = new RetType(dynamic_cast<Type*>($1));
                }

RetType:        VOID
                {
                    $$ = new RetType($1);
                }

Formals:        {
                    $$ = new Formals();
                }

Formals:        FormalsList
                {
                    $$ = new Formals(dynamic_cast<FormalsList*>($1));
                }

FormalsList:    FormalDecl
                {
                    $$ = new FormalsList(dynamic_cast<FormalDecl*>($1));
                }

FormalsList:    FormalDecl COMMA FormalsList
                {
                    $$ = new FormalsList(dynamic_cast<FormalDecl*>($1), dynamic_cast<FormalsList*>($3));
                }

FormalDecl:     Type ID
                {
                    $$ = new FormalDecl(dynamic_cast<Type*>($1), $2);
                }

Statements:     Statement
                {
                    $$ = new Statements(dynamic_cast<Statement*>($1));
                }

Statements:     Statements Statement
                {
                    $$ = new Statements(dynamic_cast<Statements*>($1), dynamic_cast<Statement*>($2));
                }

Statement:      LBRACE OpenScope Statements CloseScope RBRACE
                {
                    $$ = new Statement(dynamic_cast<Statements*>($3));
                }

Statement:      Type ID SC
                {
                    $$ = new Statement(dynamic_cast<Type*>($1),$2);
                }

Statement:      Type ID ASSIGN Exp SC
                {
                    $$ = new Statement(dynamic_cast<Type*>($1),$2, dynamic_cast<Exp*>($4));
                }

Statement:      ID ASSIGN Exp SC
                {
                    $$ = new Statement($1, dynamic_cast<Exp*>($3));
                }

Statement:      Call SC
                {
                    $$ = new Statement(dynamic_cast<Call*>($1));
                }

Statement:      RETURN SC
                {
                    $$ = new Statement("VOID");
                }

Statement:      RETURN Exp SC
                {
                    $$ = new Statement(dynamic_cast<Exp*>($2));
                }

Statement:      IF LPAREN SPECIAL_EXP RPAREN OpenScope M Statement %prec IF
                {
                    $$ = new Statement("if", dynamic_cast<Exp*>($3), dynamic_cast<Statement*>($7));
                    GlobalSemanticStateHandler::closeScope();
                    // todo: add impl. for GlobalSemanticStateHandler::backpatchIf
                    GlobalSemanticStateHandler::backpatchIf(dynamic_cast<M*>($6), dynamic_cast<Exp*>($3));
                }

Statement:      IF LPAREN SPECIAL_EXP RPAREN OpenScope M Statement ELSE
                {
                    $$ = new Statement("if else", dynamic_cast<Exp*>($3), dynamic_cast<Statement*>($7));
                    GlobalSemanticStateHandler::closeScope();
                } OpenScope N Statement CloseScope
                {
                    GlobalSemanticStateHandler::backpatchIfElse(dynamic_cast<M*>($6),dynamic_cast<N*>($11), dynamic_cast<Exp*>($3));
                    $$ = GlobalSemanticStateHandler::mergeIfElseLists(dynamic_cast<Statement*>($9), dynamic_cast<Statement*>($12));
                }

Statement:      WHILE LPAREN N Exp RPAREN
                {
                    $$ = parseBooleanCondition(dynamic_cast<Exp*>($4));
                }
                {
                    $$ = new Statement("while", dynamic_cast<Exp*>($4));
                    GlobalSemanticStateHandler::enterLoopState();
                } OpenScope Statement CloseScope
                {
                    GlobalSemanticStateHandler::exitLoopState(dynamic_cast<N*>($3),dynamic_cast<P*>($6),dynamic_cast<Statement*>($9));
                    $$ = $7;
                }

Statement:      BREAK SC
                {
                    $$ = new Statement($1);
                }

Statement:      CONTINUE SC
                {
                    $$ = new Statement($1);
                }

Statement:      SWITCH
                {
                    GlobalSemanticStateHandler::enterSwitchState();
                } LPAREN Exp
                {
                    new Exp(dynamic_cast<Exp*>($4), "switch");
                } RPAREN LBRACE OpenScope CaseList
                {
                    $$ = new Statement(dynamic_cast<Exp*>($4),dynamic_cast<CaseList*>($9));
                } CloseScope
                {
                    GlobalSemanticStateHandler::exitSwitchState();
                } RBRACE
                {
                    $$ = $10;
                }

Call:           ID LPAREN ExpList RPAREN
                {
                    $$ = new Call($1, dynamic_cast<ExpList*>($3));
                }

Call:           ID LPAREN RPAREN
                {
                    $$ = new Call($1);
                }

ExpList:        Exp
                {
                    $$ = new ExpList(dynamic_cast<Exp*>($1));
                }

ExpList:        Exp COMMA ExpList
                {
                    $$ = new ExpList(dynamic_cast<Exp*>($1), dynamic_cast<ExpList*>($3));
                }

Type:           INT
                {
                    $$ = new Type($1);
                }

Type:           BYTE
                {
                    $$ = new Type($1);
                }

Type:           BOOL
                {
                    $$ = new Type($1);
                }

Exp:            LPAREN Exp RPAREN
                {
                    $$ = new Exp(dynamic_cast<Exp*>($2));
                }

Exp:            Exp PLUS_MINUS Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1),$2,dynamic_cast<Exp*>($3), "PLUS_MINUS");
                }

Exp:            Exp MUL_DIV Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "MUL_DIV");
                }

Exp:            ID
                {
                    $$ = new Exp($1);
                }

Exp:            Call
                {
                    $$ = new Exp(dynamic_cast<Call*>($1));
                }

Exp:            NUM
                {
                    $$ = new Exp($1, "NUM");
                }

Exp:            NUM B
                {
                    $$ = new Exp($1, "BYTE");
                }

Exp:            STRING
                {
                    $$ = new Exp($1, "STRING");
                }

Exp:            TRUE
                {
                    $$ = new Exp($1, "BOOL");
                }

Exp:            FALSE
                {
                    $$ = new Exp($1, "BOOL");
                }

Exp:            NOT Exp
                {
                    $$ = new Exp($1, dynamic_cast<Exp*>($2));
                }

Exp:            Exp AND
                {
                    $$ = parseBooleanCondition(dynamic_cast<Exp*>($1));
                } Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1),$2,dynamic_cast<Exp*>($4), "AND", dynamic_cast<P*>($3));
                }

Exp:            Exp OR
                {
                    $$ = parseBooleanCondition(dynamic_cast<Exp*>($1));
                } Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1),$2,dynamic_cast<Exp*>($4), "OR", dynamic_cast<P*>($3));
                }

Exp:            Exp EQ Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "EQ");
                }

Exp:            Exp REL Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3), "REL");
                }

CaseList :      CaseDecl CaseList
                {
                    $$ = new CaseList(dynamic_cast<CaseDecl*>($1),dynamic_cast<CaseList*>($2));
                }

CaseList:       CaseDecl
                {
                    $$ = new CaseList(dynamic_cast<CaseDecl*>($1));
                }

CaseList:       DEFAULT COLON N Statements
                {
                    $$ = new CaseList(dynamic_cast<Statements*>($4), dynamic_cast<N*>($3));
                }

CaseDecl:       CASE CaseOpener NUM COLON Statements
                {
                    /* todo: maybe change CASE_NUM to NUM */
                    $$ = new CaseDecl(new Exp($3, "CASE_NUM"), dynamic_cast<Statements*>($5), dynamic_cast<Variable*>($2));
                }

OpenScope:      {
                    GlobalSemanticStateHandler::openScope();
                }

/* CloseScope is basically CS */
CloseScope:     {
                    GlobalSemanticStateHandler::closeScope();
                }

SPECIAL_EXP:    Exp
                {
                    $$ = new Exp(dynamic_cast<Exp*>($1), "STRING");
                }

M:              {
                    $$ = new M();
                }

N:              {
                    $$ = new N();
                }

/* todo: rename declaration + usage */
CaseOpener:     {
                    $$ = new Variable("OpenCase");
                }

%%

/* Code section */

Variable::Variable() : value(""), instruction(""), regName("") { }

Variable::Variable(string str) : regName("") {
    instruction = "";

    if (str == "void") {
        value = "VOID";
    } else if (str == "bool") {
        value = "BOOL";
    } else if (str == "byte") {
        value = "BYTE";
    } else if (str == "int") {
        value = "INT";
    } else {
        value = str;

        if (str == "OpenCase") {
            instruction = DeclareCaseLabel(); /* todo: implement DeclareCaseLabel */
        }
    }
}

ostream &operator<<(ostream &os, const Variable &node) {
    os << "value: " << node.value;

    return os;
}

shared_ptr<SymbolTableRecord> Program::initPrintFunc() {
    return std::make_shared<SymbolTableRecord>(SymbolTableRecord("print", {"STRING", "VOID"}, 0, true));
}

shared_ptr<SymbolTableRecord> Program::initPrintIFunc() {
    return std::make_shared<SymbolTableRecord>(SymbolTableRecord("printi", {"INT", "VOID"}, 0, true));
}

Program::Program() : Variable("Program") {
    shared_ptr<SymbolTable> symbolTable = std::make_shared<SymbolTable>();

    // initializing the print/printi function records in the (global) symbol table
    shared_ptr<SymbolTableRecord> printFunc = initPrintFunc();
    shared_ptr<SymbolTableRecord> printIFunc = initPrintIFunc();

    // putting the print and printi functions declarations in the symbolTable
    symbolTable->records.push_back(printFunc);
    symbolTable->records.push_back(printIFunc);

    // initializing the symbol-table scope stack with global scope symbol-table
    GlobalSemanticStateHandler::symbolTablesStack.push_back(symbolTable);

    // initializing the offset scope stack with the global scope offset
    GlobalSemanticStateHandler::offsetStack.push(0);

    // emitting print/printi functions declarations
    buffer.emitGlobal("declare i32 @printf(i8*, ...)");
    buffer.emitGlobal("declare void @exit(i32)");

    // emitting int specifier declaration
    buffer.emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");

    // emitting string specifier declaration
    buffer.emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
    buffer.emitGlobal("@ThrowZeroException = constant [23 x i8] c\"Error division by zero\\00\"");

    // emitting print/printi definitions
    buffer.emitGlobal("define void @printi(i32) {");
    buffer.emitGlobal("call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0), i32 %0)");
    buffer.emitGlobal("ret void");
    buffer.emitGlobal("}");
    buffer.emitGlobal("define void @print(i8*) {");
    buffer.emitGlobal("call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0), i8* %0)");
    buffer.emitGlobal("ret void");
    buffer.emitGlobal("}");
}

Funcs::Funcs() {
    if (strcmp(yytext, "") != 0) {
        // if the last lexeme is empty then it's a syntax error
        output::errorSyn(yylineno);

        exit(0);
    }
}

shared_ptr<SymbolTableRecord> FuncDecl::buildSymbolTableRecordFromFuncDecl() {
    return std::make_shared<SymbolTableRecord>(value, functionParamsTypes, 0, true);
}

FuncDecl::FuncDecl(RetType *retType, Variable *id, Formals *funcParams) {
    if (GlobalSemanticStateHandler::isDeclared(id->value)) {
        // duplicate declaration
        output::errorDef(yylineno, id->value);

        exit(0);
    }

    for (auto iter = funcParams->formals.begin(); iter != funcParams->formals.end(); ++iter) {
        if (GlobalSemanticStateHandler::isDeclared((*iter)->value) ||
            (*iter)->value == id->value) {
            // if the function name or the parameters names shadow declarations from outer scopes
            output::errorDef(yylineno, id->value);

            exit(0);
        }

        // iterating the parameters' names to check if there are duplicate parameters names
        for (auto iter2 = iter + 1; iter2 != funcParams->formals.end(); ++iter2) {
            if ((*iter)->value == (*iter2)->value) {
                output::errorDef(yylineno, (*iter)->value);

                exit(0);
            }
        }
    }

    // setting the function name of the function described by the FuncDecl object
    value = id->value;

    if (funcParams->formals.size() != 0) {
        // building the the functionParamsTypes vector of the FuncDecl object
        for (auto &formal : funcParams->formals) {
            functionParamsTypes.push_back(formal->paramType);
        }
    }

    // the last type is the return type
    functionParamsTypes.push_back(retType->value);

    // now adding said function to the symbolTable
    shared_ptr<SymbolTableRecord> funcSymbolRecord = buildSymbolTableRecordFromFuncDecl();

    // updating current function scope
    GlobalSemanticStateHandler::symbolTablesStack.back()->records.push_back(funcSymbolRecord);
    GlobalSemanticStateHandler::currentFunctionId = value;
    GlobalSemanticStateHandler::currentRunningFunctionArgumentsNumber = funcParams->formals.size(); /* todo:? */

    // generating llvm:

    string funcArgumentString = "(";
    string funcReturnType = GetLLVMType(retType->value);

    for (int i = 0; i < funcParams->formals.size(); ++i) {
        // todo: change/remove comment
        // The function has parameters which need to be printed in the LLVM function declaration
        funcArgumentString += GetLLVMType(funcParams->formals[i]->type);

        // todo: figure out how can change loop to iterator/foreach and still:
        // todo: idea: maybe change loop into iterator loop and start with i=1 and put the ',' \
                 before the LLVMType and add the first LLVMType before the loop
        if (i != funcParams->formals.size() - 1) {
            funcArgumentString += ',';
        }
    }

    funcArgumentString += ")";

    // emitting the function signature to buffer
    buffer.emit("define " + funcReturnType + " @" + value + funcArgumentString + " {");

    // emitting the allocation instructions
    buffer.emit("%stack = alloca [50 x i32]");
    buffer.emit("%args = alloca [" + to_string(funcParams->formals.size()) + " x i32]");

    // allocating registers for every function param
    for (int i = 0; i < funcParams->formals.size(); ++i) {
        string ptrRegister = registerPool.GetNewRegister();
        string dataRegister = to_string(i);
        string funcArgumentType = GetLLVMType(funcParams->formals[i]->type);

        buffer.emit("%" + ptrRegister + " = getelementptr [" + to_string(funcParams->formals.size()) + " x i32], [" +
                    to_string(funcParams->formals.size()) + " x i32]* %args, i32 0, i32 " + to_string(currentRunningFunctionArgumentsNumber - i - 1));

        if (funcArgumentType != "i32") {
            dataRegister = registerPool.GetNewRegister();
            buffer.emit("%" + dataRegister + " = zext " + funcArgumentType + " %" + to_string(i) + " to i32");
        }

        buffer.emit("store i32 %" + dataRegister + ", i32* %" + ptrRegister);
    }
}

Formals::Formals(FormalsList *formalList) {
    formals = vector<FormalDecl *>(formalList->formals);
}

FormalsList::FormalsList(FormalDecl *formalDecl) {
    formals.insert(formals.begin(), formalDecl);
}

FormalsList::FormalsList(FormalDecl *formalDecl, FormalsList *formalsList) {
    formals = vector<FormalDecl *>(formalsList->formals);
    formals.insert(formals.begin(), formalDecl);
}

Statements::Statements(Statement *statement) {
    /* todo: renaming */
    breakList = statement->breakList;
    continueList = statement->continueList;
}

Statements::Statements(Statements *statements, Statement *statement) {
    /* todo: renaming */
    breakList = buffer.merge(statements->breakList, statement->breakList);
    continueList = buffer.merge(statements->continueList, statement->continueList);
}

Statement::Statement(Statements *statements) {
    /* todo: renaming */
    dataTag = "statement block";
    breakList = states->breakList;
    continueList = states->continueList;
}

/* todo: */
Statement::Statement(Type *type, Variable *id) {
    if (GlobalSemanticStateHandler::isDeclared(id->value)) {
        output::errorDef(yylineno, id->value);

        exit(0);
    }

    int offset = GlobalSemanticStateHandler::offsetStack.top()++;
    vector<string> variableType = {type->value};
    shared_ptr<SymbolTableRecord> variableRecord = std::make_shared<SymbolTableRecord>(id->value, variableType, offset, false);

    GlobalSemanticStateHandler::symbolTablesStack.back()->records.push_back(variableRecord);
}

/* todo: */
Statement::Statement(Type *type, Variable *id, Exp *exp) {
    if (GlobalSemanticStateHandler::isDeclared(id->value)) {
        output::errorDef(yylineno, id->value);

        exit(0);
    }
    if ((type->value == exp->type) || (type->value == "INT" && exp->type == "BYTE")) {
        int offset = GlobalSemanticStateHandler::offsetStack.top()++;
        vector<string> variableType = {type->value};
        shared_ptr<SymbolTableRecord> variableRecord = std::make_shared<SymbolTableRecord>(id->value, variableType, offset, false);

        GlobalSemanticStateHandler::symbolTablesStack.back()->records.push_back(variableRecord);
    } else {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

/* todo: */
Statement::Statement(Variable *id, Exp *exp) {
    if (!GlobalSemanticStateHandler::isDeclared(id->value)) {
        output::errorUndef(yylineno, id->value);

        exit(0);
    }
}

Statement::Statement(Call *call) {
    /* todo: renaming */
    dataTag = "function call";
    breakList = vector<pair<int, BranchLabelIndex>>();
    continueList = vector<pair<int, BranchLabelIndex>>();
}

/* todo: */
Statement::Statement(const string &funcReturnType) {
    // checking if the current function scope is of void type
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->isFunc && record->name == GlobalSemanticStateHandler::currentFunctionId) {
                if (record->type.back() == funcReturnType) {
                } else {
                    output::errorMismatch(yylineno);

                    exit(0);
                }
            }
        }
    }
}

/* todo: */
Statement::Statement(Exp *exp) {
    // checking if the current function scope is of the specified type
    if (exp->type == "VOID") {
        output::errorMismatch(yylineno);

        exit(0);
    }

    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->isFunc && record->name == GlobalSemanticStateHandler::currentFunctionId) {
                if (record->type.back() == exp->type) {
                } else if (record->type.back() == "INT" && exp->type == "BYTE") {
                    // do nothing because automatic cast from byte to int is allowed
                } else {
                    output::errorMismatch(yylineno);

                    exit(0);
                }
            }
        }
    }
}

/* todo: */
Statement::Statement(string type, Exp *exp) {
    if (exp->type != "BOOL") {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

/* todo: */
Statement::Statement(Variable *variable) {
    if (GlobalSemanticStateHandler::nestedLoopDepth == 0 && !GlobalSemanticStateHandler::isInSwitchState) {
        // not withing a loop so break/continue is invalid in this context
        if (variable->value == "break") {
            output::errorUnexpectedBreak(yylineno);

            exit(0);
        } else if (variable->value == "continue") {
            output::errorUnexpectedContinue(yylineno);

            exit(0);
        } else {
        }
    } else if (variable->value == "continue" && GlobalSemanticStateHandler::isInSwitchState) {
        output::errorUnexpectedContinue(yylineno);

        exit(0);
    }
}

/* todo: */
Statement::Statement(Exp *exp, CaseList *caseList) {
    // making sure the switch-cases types match
    GlobalSemanticStateHandler::enterSwitchState();

    if (exp->type != "INT" && exp->type != "BYTE") {
        output::errorMismatch(yylineno);

        exit(0);
    }

    for (auto &caseDeclaration : caseList->caseDeclarations) {
        if (caseDeclaration->value != "INT" && caseDeclaration->value != "BYTE") {
            output::errorMismatch(yylineno);

            exit(0);
        }
    }
}

/* todo: */
Call::Call(Variable *id) {
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == id->value) {
                if (!record->isFunc) {
                    output::errorUndefFunc(yylineno, id->value);

                    exit(0);
                } else if (record->isFunc && record->type.size() == 1) {
                    value = record->type.back();

                    return;
                } else {
                    record->type.pop_back();
                    output::errorPrototypeMismatch(yylineno, id->value, record->type);

                    exit(0);
                }
            }
        }
    }

    output::errorUndefFunc(yylineno, id->value);

    exit(0);
}

/* todo: */
Call::Call(Variable *id, ExpList *list) {
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == id->value) {
                if (!record->isFunc) {
                    output::errorUndefFunc(yylineno, id->value);

                    exit(0);
                } else if (record->isFunc && record->type.size() == list->expressionsList.size() + 1) {
                    for (unsigned int i = 0; i < list->expressionsList.size(); ++i) {
                        if (list->expressionsList[i].type == record->type[i]) {
                            continue;
                        } else if (list->expressionsList[i].type == "BYTE" && record->type[i] == "INT") {
                            continue;
                        }

                        record->type.pop_back();
                        output::errorPrototypeMismatch(yylineno, id->value, record->type);

                        exit(0);
                    }

                    value = record->type.back();

                    return;
                } else {
                    record->type.pop_back();
                    output::errorPrototypeMismatch(yylineno, id->value, record->type);

                    exit(0);
                }
            }
        }
    }

    output::errorUndefFunc(yylineno, id->value);

    exit(0);
}

/* todo: */
ExpList::ExpList(Exp *exp) {
    expressionsList.insert(expressionsList.begin(), exp);
}

/* todo: */
ExpList::ExpList(Exp *exp, ExpList *expList) {
    expressionsList = vector<Exp>(expList->expressionsList);
    expressionsList.insert(expressionsList.begin(), exp);
}

/* todo: */
Exp::Exp(Exp *exp) {
    value = exp->value;
    type = exp->type;
    realBooleanValue = exp->realBooleanValue;
}

/* todo: */
Exp::Exp(Exp *exp1, Variable *op, Exp *exp2, const string &taggedType) {
    bool isE1Num = exp1->type == "INT" || exp1->type == "BYTE";
    bool isE2Num = exp2->type == "INT" || exp2->type == "BYTE";
    bool isRelOp = taggedType == "EQ" || taggedType == "REL";
    bool isBinOp = taggedType == "PLUS_MINUS" || taggedType == "MUL_DIV";
    bool isBoolOp = taggedType == "OR" || taggedType == "AND";

    if (isE1Num && isE2Num) {
        if (isRelOp) {
            type = "BOOL";
        } else if (isBinOp) {
            if (exp1->type == "INT" || exp2->type == "INT") {
                type = "INT"; // automatic cast to the wider number type
            } else {
                type = "BYTE";
            }
        }
    } else if (exp1->type == "BOOL" && exp2->type == "BOOL") {
        type = "BOOL";

        if (isBoolOp) {
            if if (op->value == "OR") {
                realBooleanValue = exp1->realBooleanValue || exp2->realBooleanValue;
            } else if (op->value == "AND") {
                realBooleanValue = exp1->realBooleanValue && exp2->realBooleanValue;
            }
        } else {
            // only a boolean operation is allowed between 2 boolean expressions
            output::errorMismatch(yylineno);

            exit(0);
        }
    } else {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

/* todo: */
Exp::Exp(Variable *variable) {
    // making sure the variable is declared
    if (!GlobalSemanticStateHandler::isDeclaredVariable(variable->value)) {
        output::errorUndef(yylineno, variable->value);

        exit(0);
    }

    for (auto symbolTableIter = GlobalSemanticStateHandler::symbolTablesStack.rbegin();
         symbolTableIter != GlobalSemanticStateHandler::symbolTablesStack.rend();
         ++symbolTableIter) {
            for (auto &record : (*symbolTableIter)->records) {
                if (record->name == variable->value) {
                    value = variable->value;
                    type = record->type.back();

                    return;
                }
            }
    }
}

/* todo: */
Exp::Exp(Variable *variable, string taggedType) : Variable::Variable(variable->value) {
    type = taggedType;

    if (type == "NUM") {
        type = "INT";
    } else if (type == "BYTE") {
        // check that size is legal for type BYTE
        if (stoi(variable->value) > 255) {
            output::errorByteTooLarge(yylineno, variable->value);

            exit(0);
        }
    } else if (type == "BOOL") {
        if (variable->value == "true") {
            realBooleanValue = true;
        } else {
            realBooleanValue = false;
        }
    }
}

/* todo: */
Exp::Exp(Variable *variable, Exp *exp) {
    if (exp->type != "BOOL") {
        // not a boolean expression, can't apply NOT
        output::errorMismatch(yylineno);

        exit(0);
    }

    type = "BOOL";
    realBooleanValue = !realBooleanValue; // applying not
}

/* todo: */
Exp::Exp(Exp *exp, string tag) {
    if (tag == "switch" && exp->type != "INT" && exp->type != "BYTE") {
        output::errorMismatch(yylineno);

        exit(0);
    }
}

/* todo: */
CaseList::CaseList(CaseDecl *caseDecl, CaseList *caseList) : CaseList::CaseList() {
    caseDeclarations = vector<CaseDecl *>(caseList->caseDeclarations);
    caseDeclarations.push_back(caseDecl);
}

/* todo: */
CaseList::CaseList(CaseDecl *caseDecl) : CaseList::CaseList() {
    caseDeclarations.push_back(caseDecl);
}

/* todo: */
CaseDecl::CaseDecl(Exp *expression, Statements *statements) {
    if (expression->type != "INT" && expression->type != "BYTE") {
        output::errorMismatch(yylineno);

        exit(0);
    }

    value = expression->type;
}

P::P(Exp *leftHandInstr) {
    /* todo: renaming */
    loc = buffer.emit("br i1 %" + leftHandInstr->regName + ", label @, label @");
    instruction = buffer.genLabel();
}

M::M() {
    /* todo: renaming */
    instruction = buffer.genLabel();
}

N::N() {
    /* todo: renaming */
    loc = buffer.emit("br label @");
    instruction = buffer.genLabel();
}

// GlobalSemanticStateHandler namespace

void GlobalSemanticStateHandler::openScope() {
    symbolTablesStack.push_back(make_shared<SymbolTable>());
    offsetStack.push(offsetStack.top());
}

void GlobalSemanticStateHandler::closeScope() {
    shared_ptr<SymbolTable> currentSymbolTable = symbolTablesStack.back();

    output::endScope();

    for (auto &record : currentSymbolTable->records) {
        if (!record->isFunc) {
            output::printID(record->name, record->offset, record->type[0]);
        } else {
            string funcReturnType = record->type.back();

            // that's the return type from the vector
            record->type.pop_back();
            output::printID(record->name, record->offset,
                            output::makeFunctionType(funcReturnType, record->type));
        }
    }

    currentSymbolTable->records.clear();
    symbolTablesStack.pop_back();
    offsetStack.pop();
}

void GlobalSemanticStateHandler::enterLoopState() {
    nestedLoopDepth++;
}

void GlobalSemanticStateHandler::exitLoopState() {
    nestedLoopDepth--;
}

void GlobalSemanticStateHandler::enterSwitchState() {
    isInSwitchState = true;
}

void GlobalSemanticStateHandler::exitSwitchState() {
    isInSwitchState = false;
}

void GlobalSemanticStateHandler::exitProgramFuncsState() {
    currentFunctionId = "";
}

void GlobalSemanticStateHandler::exitProgramRuntimeState() {
    shared_ptr<SymbolTable> globalScopeSymbolTable = symbolTablesStack.front();
    bool doesMainFuncExist = false;

    // looking if there's a main function in the symbol table of the global scope
    for (auto &record : globalScopeSymbolTable->records) {
        if (record->isFunc && record->name == "main" && record->type.back() == "VOID" &&
            record->type.size() == 1) {
            doesMainFuncExist = true;
        }
    }

    if (!doesMainFuncExist) {
        output::errorMainMissing();

        exit(0);
    }

    closeScope();
}

shared_ptr<SymbolTableRecord> GlobalSemanticStateHandler::makeParamSymbolRecord(string value,
                                                                                vector<string> currentParamType,
                                                                                int currentOffset) {
    return make_shared<SymbolTableRecord>(value, currentParamType, currentOffset, false);
}

void GlobalSemanticStateHandler::insertFunctionParametersToSymbolTable(Formals *formals) {
    int currentOffset;
    vector<string> currentParamType;
    shared_ptr<SymbolTableRecord> currentParamRecord;

    // iterating over all the function parameters and adding each one as a record in the symbol table
    for (unsigned int i = 0; i < formals->formals.size(); ++i) {
        currentOffset =  -i - 1;
        currentParamType = {formals->formals[i]->paramType};

        currentParamRecord = makeParamSymbolRecord(formals->formals[i]->value, currentParamType, currentOffset);

        symbolTablesStack.back()->records.push_back(currentParamRecord);
    }
}

bool GlobalSemanticStateHandler::isDeclaredVariable(const string &name) {
    // traversing the symbol tables of all the scopes to check if the given variable name exists
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == name && !record->isFunc) {
                return true;
            }
        }
    }

    return false;
}

bool GlobalSemanticStateHandler::isDeclared(const string &name) {
    // traversing the symbol tables of all the scopes to check if the given var/func name exists
    for (auto &symbolTable : GlobalSemanticStateHandler::symbolTablesStack) {
        for (auto &record : symbolTable->records) {
            if (record->name == name) {
                return true;
            }
        }
    }

    return false;
}


int main() {
    return yyparse();
}

int yyerror(const char * message) {
    output::errorSyn(yylineno);
    exit(0);
}